from io import StringIO
from typing import cast, List, Optional

BITS_8 = 8
BITS_16 = BITS_8 * 2
BITS_WORD = BITS_16
BITS_64 = BITS_8 * 8


def split(to_split: str = "", by=4) -> str:
    if (
        to_split.startswith("0b")
        or to_split.startswith("0x")
        or to_split.startswith("\\x")
    ):
        prefix = to_split[0:2]
        actual_value: str = to_split[2:].replace(" ", "")
    else:
        prefix = ""
        actual_value = to_split.replace(" ", "")

    if by > 0:
        i = len(actual_value)
        groups: List[str] = []
        while i > 0:
            i = i - by
            group = actual_value[max(0, i) : i + by]
            groups.insert(0, group)
        return prefix + " ".join(groups)
    else:
        return to_split


def split_to_array(to_split: str = "", by=4) -> List[str]:
    if to_split.startswith("0b") or to_split.startswith("0x"):
        actual_value: str = to_split[2:].replace(" ", "")
    else:
        actual_value = to_split.replace(" ", "")

    if by > 0:
        i = len(actual_value)
        groups: List[str] = []
        while i > 0:
            i = i - by
            group = actual_value[max(0, i) : i + by]
            groups.insert(0, group)
        return groups
    else:
        return [to_split]


def to_int(value) -> int:
    if type(value) == int:
        actual_value: int = value
    elif type(value) == str:
        str_value: str = cast(str, value)
        if str_value.startswith("0b"):
            # Replacing spaces with empty sting in case
            # the binary representation embeds spaces to
            # separate groups of bits, as in:
            # 0b0001 0101 1000 1010
            actual_value = int(str_value.replace(" ", ""), 2)
        elif str_value.startswith("0x"):
            # Replacing spaces (see previous comment)
            actual_value = int(str_value.replace(" ", ""), 16)
        else:
            actual_value = int(str_value)
    else:
        raise TypeError(
            "Unknown type for input {value}: {type}".format(
                value=value, type=type(value)
            )
        )
    return actual_value


def to_hex(value, bit_width: int = BITS_64, group=2, escape=False) -> str:
    hex_str = ("\\x" if escape else "0x") + "{0:x}".format(to_int(value)).rjust(
        bit_width // 4, "0"
    )
    if group > 0:
        return split(hex_str, by=group)


def to_bin(value, bit_width: int = BITS_64, group=4) -> str:
    bin_str = "0b" + "{0:b}".format(to_int(value)).rjust(bit_width, "0")
    if group > 0:
        return split(bin_str, by=group)


def shr(value, numbits: int, bit_width: int = BITS_64, group=4) -> str:
    shifted_value = to_int(value) >> numbits
    formatted = "{0:b}".format(shifted_value).rjust(bit_width, "0")
    return "0b" + split(formatted, by=group)


def shl(value, numbits: int, bit_width: int = BITS_64, group=4) -> str:
    shifted_value = to_int(value) << numbits
    formatted = "{0:b}".format(shifted_value).rjust(bit_width, "0")
    return "0b" + split(formatted[len(formatted) - bit_width :], by=group)


def info(value, bit_width: int = BITS_64, stdout: Optional[StringIO] = None):
    hex_val = to_hex(value, bit_width=bit_width)
    bin_val = to_bin(value, bit_width=bit_width)
    dec_val = "{0}".format(to_int(value))
    if stdout:
        stdout.write("hex...: {0}\n".format(hex_val))
        stdout.write("bin...: {0}\n".format(bin_val))
        stdout.write("dec...: {0}\n".format(dec_val))
        stdout.flush()
        stdout.seek(0)
    else:
        print("hex...:", hex_val)
        print("bin...:", bin_val)
        print("dec...:", dec_val)


def reverse_bytes(value) -> int:
    int_value = to_int(value)
    binary_value = to_bin(int_value)
    bytes_list: List[str] = split_to_array(binary_value, BITS_8)
    reversed_byte_value = int("".join(reversed(bytes_list)), 2)
    return reversed_byte_value


def offset_info(start_addr=0, num_bytes=8, bit_width=BITS_64, group=4):
    addr: int = start_addr
    offset: int = 0
    start_addr_hex = to_hex(addr, bit_width=bit_width, group=group)
    count = 0
    for i in range(0, num_bytes):
        count += 1
        addr_hex = to_hex(addr, bit_width=bit_width, group=group)
        line = f"{count}) {addr_hex}...[{start_addr_hex} + {offset}]"
        print(line)
        addr += 1
        offset += 1
        if offset % BITS_8 == 0:
            print("-" * (len(line)))


def hex_bytes_to_ascii(byte_str: str) -> str:
    hex_vals = split_to_array(byte_str.replace(" ", "").replace("0x", ""), by=2)
    ascii_codes: List[int] = [int("0x{0}".format(hex_val), 16) for hex_val in hex_vals]
    chars = [chr(c) for c in ascii_codes]
    return "".join(chars)


def ascii_to_hex_bytes(ascii_vals: str, bit_width=BITS_8, little_endian=True, escape=True, group=2) -> str:
    hex_vals = [to_hex(ord(a), bit_width=bit_width, group=2, escape=escape) for a in ascii_vals]

    return "".join(hex_vals[::-1] if little_endian else hex_vals)


def hex_pattern(
    value: int = 0xDEADC0DE,
    bit_width=BITS_WORD,
    repeat=10,
    little_endian=True,
    escape=True,
    max_bytes=-1
) -> str:
    pattern: List[str] = []
    if little_endian:
        repeat_sequence: List[str] = [
            "\\x{0}".format(b)
            for b in list(
                reversed(
                    split_to_array(to_hex(value, bit_width=bit_width, group=2), by=2)
                )
            )
        ]

    else:
        repeat_sequence = [
            ("\\x{0}" if escape else "0x{0}").format(b)
            for b in split_to_array(to_hex(value, bit_width=bit_width, group=2), by=2)
        ]
    byte_count: int = 0
    if repeat > 1:
        for i in range(0, repeat):
            if 0 < max_bytes == byte_count:
                break
            i_hex = to_hex(i, bit_width=8, group=2, escape=True)
            byte_count += 1
            pattern.insert(0, i_hex)
            for b in reversed(repeat_sequence):
                pattern.insert(0, b)
                byte_count += 1
                if 0 < max_bytes == byte_count:
                    break
    else:
        for b in reversed(repeat_sequence):
            pattern.insert(0, b)
            byte_count += 1
            if 0 < max_bytes == byte_count:
                break

    return "".join(pattern)
